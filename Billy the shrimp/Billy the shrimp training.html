<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billy the shrimp</title>
    <style>
        @font-face {
            font-family: 'Peralta';
            src: url('font/peralta/peralta-regular.ttf') format('truetype');
        }
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
            font-family: 'Peralta', cursive;
            overflow: hidden;
            color: white;
            user-select: none;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            border: 4px solid #005f99;
        }
        canvas {
            display: block;
            background: transparent;
            cursor: crosshair;
        }
        #gameContainer:hover {
            cursor: default;
        }
        .instructions {
            font-size: 16px;
            line-height: 1.4;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            font-family: 'Peralta', cursive;
        }
        button {
            background-color: #ff6600;
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 10px;
            font-family: 'Peralta', cursive;
        }
        button:hover {
            background-color: #ff8533;
        }
        #musicToggle {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid white;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-family: 'Peralta', cursive;
        }
        #musicToggle:hover {
            background: rgba(0, 0, 0, 0.7);
        }
    </style>
    <link rel="stylesheet" href="font/peralta/peralta.css">
</head>
<body>

<div id="gameContainer">
    <div id="ui">
        Level: <span id="level">1</span> | 
        Bottles hit: <span id="enemiesDefeated">0</span>/10 |
        Shots remaining: <span id="shotsRemaining">10</span>
    </div>
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    
    <button id="musicToggle" onclick="toggleMusic()">ðŸ”‡ Musica</button>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const levelEl = document.getElementById('level');
    const enemiesDefeatedEl = document.getElementById('enemiesDefeated');
    const shotsRemainingEl = document.getElementById('shotsRemaining');
    const musicToggle = document.getElementById('musicToggle');

    let gameActive = false;
    let showQuestScreen = true;
    let showGameOverScreen = false;
    let showLevelCompleteScreen = false;
    let level = 1;
    let enemiesDefeated = 0;
    let shotsRemaining = 10;
    let frames = 0;
    let enemiesPerLevel = 10;
    let finalEnemiesDefeated = 0;
    let finalShotsRemaining = 0;
    let shotsUsed = 0;

    const backgroundMusic = new Audio('sound/main_theme.mp3');
    backgroundMusic.loop = true;
    backgroundMusic.volume = 0.5;
    let musicPlaying = false;

    const playerFrames = {
        right: [],
        left: []
    };
    
    const backgroundImage = new Image();
    backgroundImage.src = 'img/background/seabed.png';
    
    const bottleSprite = new Image();
    bottleSprite.src = 'img/prop/bottle.png';
    
    const bubbleSprite = new Image();
    bubbleSprite.src = 'img/bubbles/bubble_1.png';
    
    const gunshotSound = new Audio('sound/gunshot.mp3');
    const cockingSound = new Audio('sound/cocking.mp3');
    
    let currentFrame = 0;
    let isCharging = false;
    let isShooting = false;
    let animationTimer = 0;
    const ANIMATION_SPEED = 1;
    
    let totalImagesToLoad = 3;
    let imagesLoaded = 0;
    
    function imageLoaded() {
        imagesLoaded++;
        console.log('Immagini caricate:', imagesLoaded, '/', totalImagesToLoad);
        if (imagesLoaded === totalImagesToLoad) {
            console.log('Tutte le immagini caricate!');
        }
    }
    
    function imageError(src) {
        console.error('Errore caricamento:', src);
        imagesLoaded++;
    }
    
    function startBackgroundMusic() {
        if (!musicPlaying) {
            backgroundMusic.play().catch(error => {
                console.log('Errore nella riproduzione della musica:', error);
                musicToggle.textContent = "ðŸ”‡ Clicca per musica";
            });
            musicPlaying = true;
            musicToggle.textContent = "ðŸ”Š Musica";
        }
    }
    
    function stopBackgroundMusic() {
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0;
        musicPlaying = false;
        musicToggle.textContent = "ðŸ”‡ Musica";
    }
    
    function toggleMusic() {
        if (musicPlaying) {
            stopBackgroundMusic();
        } else {
            startBackgroundMusic();
        }
    }
    
    function loadPlayerFrames() {
        const frameCount = 3;
        
        for (let i = 1; i <= frameCount; i++) {
            const rightFrame = new Image();
            rightFrame.src = `img/player_frames/billy_right_${i}.png`;
            rightFrame.onload = imageLoaded;
            rightFrame.onerror = () => imageError(`billy_right_${i}.png`);
            playerFrames.right.push(rightFrame);
            
            const leftFrame = new Image();
            leftFrame.src = `img/player_frames/billy_left_${i}.png`;
            leftFrame.onload = imageLoaded;
            leftFrame.onerror = () => imageError(`billy_left_${i}.png`);
            playerFrames.left.push(leftFrame);
            
            totalImagesToLoad += 2;
        }
    }
    
    backgroundImage.onload = imageLoaded;
    backgroundImage.onerror = () => imageError('background.jpg');
    bottleSprite.onload = imageLoaded;
    bottleSprite.onerror = () => imageError('bottle.png');
    bubbleSprite.onload = imageLoaded;
    bubbleSprite.onerror = () => imageError('bubble_1.png');
    
    loadPlayerFrames();

    const player = {
        x: canvas.width / 2 - 40,
        y: canvas.height / 2 - 40,
        width: 80,
        height: 80,
        color: '#ff6600',
        speed: 5,
        clawSize: 15,
        angle: 0,
        vx: 0, 
        vy: 0, 
        friction: 0.95,
        facingRight: true
    };

    let bullets = [];
    let bottles = [];
    let bubbles = [];

    const keys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
        KeyW: false,
        KeyS: false,
        KeyA: false,
        KeyD: false,
        Enter: false
    };

    window.addEventListener('keydown', (e) => {
        if(keys.hasOwnProperty(e.code)) keys[e.code] = true;
        
        if (e.code === 'Enter') {
            if (showQuestScreen) {
                startGame();
            } else if (showGameOverScreen) {
                resetGame();
            } else if (showLevelCompleteScreen) {
                nextLevel();
            }
        }
    });

    window.addEventListener('keyup', (e) => {
        if(keys.hasOwnProperty(e.code)) keys[e.code] = false;
    });

    canvas.addEventListener('mousemove', (e) => {
        
        if (!gameActive) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        player.angle = Math.atan2(mouseY - (player.y + player.height / 2), mouseX - (player.x + player.width / 2));
        
        const angleDeg = player.angle * 180 / Math.PI;
        player.facingRight = (angleDeg >= -90 && angleDeg <= 90);
    });

    canvas.addEventListener('mousedown', (e) => {
        if (!gameActive) return;
        if (!gameActive || showLevelCompleteScreen || showGameOverScreen) return;

        if (e.button === 2) {
            if (shotsRemaining > 0) {
                startCharging();
            }
        } else if (e.button === 0) {
            if (isCharging && shotsRemaining > 0) {
                shoot();
                
            }
        }
    });

    canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        return false;
    });

    function startGame() {
        gameActive = true;
        showQuestScreen = false;
        startBackgroundMusic();
        update();
    }

    function startCharging() {
        if (isShooting) return;
        isCharging = true;
        currentFrame = 0;
        animationTimer = 0;
        playCockingSound()
    }

    function shoot() {
        if (!gameActive || showLevelCompleteScreen || showGameOverScreen) return;
        if (isShooting) return;

        isCharging = false;
        isShooting = true;
        currentFrame = 2;
        animationTimer = 0;
        

        if (shotsRemaining > 0) {
            shotsRemaining--;
            shotsRemainingEl.innerText = shotsRemaining;
        }

        const bulletSpeed = 10;
        const startOffset = player.width / 2 + player.clawSize / 2;
        const bulletX = player.x + player.width / 2 + startOffset * Math.cos(player.angle);
        const bulletY = player.y + player.height / 2 + startOffset * Math.sin(player.angle);

        bullets.push({
            x: bulletX,
            y: bulletY,
            size: 10,
            speedX: bulletSpeed * Math.cos(player.angle),
            speedY: bulletSpeed * Math.sin(player.angle),
            growth: 0.3
        });

        const recoilForce = 6; 
        player.vx -= recoilForce * Math.cos(player.angle);
        player.vy -= recoilForce * Math.sin(player.angle);

        playGunshotSound();

        
    }


    function updateAnimation() {
        animationTimer++;
        
        if (isCharging && animationTimer >= ANIMATION_SPEED) {
            if (currentFrame < 2) {
                currentFrame++;
            }
            animationTimer = 0;
        } else if (isShooting && animationTimer >= ANIMATION_SPEED) {
            if (currentFrame > 0) {
                currentFrame--;
            } else {
                isShooting = false;
            }
            animationTimer = 0;
        }
    }

    function getCurrentPlayerFrame() {
        const frames = player.facingRight ? playerFrames.right : playerFrames.left;
        return frames[currentFrame] || frames[0];
    }

    function playGunshotSound() {
        const sound = new Audio('sound/gunshot.mp3');
        sound.volume = 0.3;
        sound.play().catch(error => {
            console.log('Errore nella riproduzione audio:', error);
        });
    }

    function playCockingSound() {
        const sound = new Audio('sound/cocking.mp3');
        cockingSound.volume = 1;
        cockingSound.play().catch(error => {
            console.log('Errore nella riproduzione audio di cocking:', error);
        });
    }
    
    function playSonicPop() {
        const sound = new Audio('sound/glass_breack.mp3');
        sound.volume = 1;
        sound.play().catch(error => {
            console.log('Errore nella riproduzione audio:', error);
        });
    }

    function update() {
        if (!gameActive) return;

        updateAnimation();

        if ((keys.KeyW || keys.ArrowUp) && player.y > 0) player.y -= player.speed;
        if ((keys.KeyS || keys.ArrowDown) && player.y < canvas.height - player.height) player.y += player.speed;
        if ((keys.KeyA || keys.ArrowLeft) && player.x > 0) player.x -= player.speed;
        if ((keys.KeyD || keys.ArrowRight)) player.x += player.speed;

        player.x += player.vx;
        player.y += player.vy;
        player.vx *= player.friction;
        player.vy *= player.friction;

        if (Math.abs(player.vx) < 0.01) player.vx = 0;
        if (Math.abs(player.vy) < 0.01) player.vy = 0;

        if (player.x < 0) { player.x = 0; player.vx = 0; }
        if (player.y < 0) { player.y = 0; player.vy = 0; }
        if (player.x > canvas.width - player.width) { player.x = canvas.width - player.width; player.vx = 0; }
        if (player.y > canvas.height - player.height) { player.y = canvas.height - player.height; player.vy = 0; }

        bullets.forEach((bullet, index) => {
            bullet.x += bullet.speedX;
            bullet.y += bullet.speedY;
            bullet.size += bullet.growth;
            if (bullet.x < -100 || bullet.x > canvas.width + 100 || bullet.y < -100 || bullet.y > canvas.height + 100) {
                bullets.splice(index, 1);
            }
        });

        if (frames % 90 === 0 && bottles.length < getMaxBottles()) {
            const spawnX = Math.random() * (canvas.width - 60);
            
            bottles.push({
                x: spawnX,
                y: -60,
                width: 60,
                height: 60,
                speed: getBottleSpeed(),
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.1
            });
        }

        bottles.forEach((bottle, bIndex) => {
            bottle.y += bottle.speed;
            bottle.rotation += bottle.rotationSpeed;

            bullets.forEach((bullet, buIndex) => {
                const dist = Math.hypot(bullet.x - (bottle.x + bottle.width/2), bullet.y - (bottle.y + bottle.height/2));
                if (dist < bullet.size + bottle.width/3) {
                    createExplosion(bottle.x, bottle.y);
                    bottles.splice(bIndex, 1);
                    bullets.splice(buIndex, 1);
                    enemiesDefeated++;
                    enemiesDefeatedEl.innerText = enemiesDefeated;
                    
                    if (enemiesDefeated >= enemiesPerLevel) {
                        completeLevel();
                        return;
                    }
                }
            });

            if (bottle.y > canvas.height) {
                bottles.splice(bIndex, 1);
            }
        });

        bubbles.forEach((bubble, index) => {
            bubble.y -= bubble.speed;
            bubble.life -= 0.02;
            if (bubble.life <= 0) bubbles.splice(index, 1);
        });

        frames++;
        if (shotsRemaining === 0 && bullets.length === 0 && enemiesDefeated < enemiesPerLevel) {
            endGame();
            return;
        }
        requestAnimationFrame(draw);
    }

    function getMaxBottles() {
        return 3 + Math.floor(level / 2);
    }

    function getBottleSpeed() {
        return 2 + Math.random() * 1 + (level * 0.1);
    }

    function createExplosion(x, y) {
        for (let i = 0; i < 5; i++) {
            bubbles.push({
                x: x + Math.random() * 20,
                y: y + Math.random() * 20,
                size: 10 + Math.random() * 10,
                speed: Math.random() * 2,
                life: 1
            });
        }
        playSonicPop()
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        
        if (showQuestScreen) {
            drawQuestScreen();
            requestAnimationFrame(draw);
            return;
        }
        
        if (showGameOverScreen) {
            drawGameOverScreen();
            requestAnimationFrame(draw);
            return;
        }
        
        if (showLevelCompleteScreen) {
            drawLevelCompleteScreen();
            requestAnimationFrame(draw);
            return;
        }
        
        ctx.save();
        ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
        ctx.rotate(player.angle);

        const currentImage = getCurrentPlayerFrame();
        ctx.drawImage(currentImage, -player.width / 2, -player.height / 2, player.width, player.height);
        
        ctx.restore();
        
        bullets.forEach(bullet => {
            ctx.drawImage(bubbleSprite, bullet.x - bullet.size/2, bullet.y - bullet.size/2, bullet.size, bullet.size);
        });

        bottles.forEach(bottle => {
            ctx.save();
            ctx.translate(bottle.x + bottle.width / 2, bottle.y + bottle.height / 2);
            ctx.rotate(bottle.rotation);
            ctx.drawImage(bottleSprite, -bottle.width / 2, -bottle.height / 2, bottle.width, bottle.height);
            ctx.restore();
        });

        bubbles.forEach(bubble => {
            ctx.globalAlpha = bubble.life;
            ctx.drawImage(bubbleSprite, bubble.x, bubble.y, bubble.size, bubble.size);
            ctx.globalAlpha = 1;
        });

        if (gameActive) {
            requestAnimationFrame(update);
        } else {
            requestAnimationFrame(draw);
        }
    }
    
    function drawQuestScreen() {
        // Sfondo semi-trasparente
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Titolo
        ctx.font = 'bold 48px Peralta';
        ctx.fillStyle = '#ff6600';
        ctx.textAlign = 'center';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 4;
        ctx.strokeText('BILLY THE SHRIMP', canvas.width / 2, canvas.height / 2 - 80);
        ctx.fillText('BILLY THE SHRIMP', canvas.width / 2, canvas.height / 2 - 80);
        
        // Sottotitolo
        ctx.font = '24px Peralta';
        ctx.fillStyle = 'white';
        ctx.lineWidth = 3;
        ctx.strokeText('Training Session', canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillText('Training Session', canvas.width / 2, canvas.height / 2 - 20);
        
        // Obiettivo
        ctx.font = '20px Peralta';
        ctx.strokeText('Hit 10 bottles with 10 shots', canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText('Hit 10 bottles with 10 shots', canvas.width / 2, canvas.height / 2 + 20);
        
        // ISTRUZIONI AGGIUNTE
        ctx.font = '16px Peralta';
        ctx.fillStyle = '#ccc';
        ctx.lineWidth = 2;
        ctx.strokeText('Use Arrows or AWSD to move, Mouse to aim', canvas.width / 2, canvas.height / 2 + 50);
        ctx.fillText('Use Arrows or AWSD to move, Mouse to aim', canvas.width / 2, canvas.height / 2 + 50);
        ctx.strokeText('Right click to cock the claw, Left click to shoot', canvas.width / 2, canvas.height / 2 + 80);
        ctx.fillText('Right click to cock the claw, Left click to shoot', canvas.width / 2, canvas.height / 2 + 80);
        
        // Istruzioni per iniziare
        ctx.font = '18px Peralta';
        ctx.fillStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.strokeText('Press ENTER to start', canvas.width / 2, canvas.height / 2 + 130);
        ctx.fillText('Press ENTER to start', canvas.width / 2, canvas.height / 2 + 130);
    }
    
    function drawGameOverScreen() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.font = 'bold 48px Peralta';
        ctx.fillStyle = '#ff3333';
        ctx.textAlign = 'center';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 4;
        ctx.strokeText('TRAINING FAILED', canvas.width / 2, canvas.height / 2 - 80);
        ctx.fillText('TRAINING FAILED', canvas.width / 2, canvas.height / 2 - 80);
        
        ctx.font = '24px Peralta';
        ctx.fillStyle = 'white';
        ctx.lineWidth = 3;
        ctx.strokeText('Training failed, try again', canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillText('Training failed, try again', canvas.width / 2, canvas.height / 2 - 20);
        
        ctx.font = '20px Peralta';
        ctx.strokeText(`Bottles hit: ${finalEnemiesDefeated}/10`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText(`Bottles hit: ${finalEnemiesDefeated}/10`, canvas.width / 2, canvas.height / 2 + 20);
        
        ctx.strokeText(`Shots used: ${finalShotsRemaining}`, canvas.width / 2, canvas.height / 2 + 50);
        ctx.fillText(`Shots used: ${finalShotsRemaining}`, canvas.width / 2, canvas.height / 2 + 50);
        
        ctx.font = '18px Peralta';
        ctx.fillStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.strokeText('Press ENTER to try again', canvas.width / 2, canvas.height / 2 + 100);
        ctx.fillText('Press ENTER to try again', canvas.width / 2, canvas.height / 2 + 100);
    }
    
    function drawLevelCompleteScreen() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.font = 'bold 48px Peralta';
        ctx.fillStyle = '#ffcc00';
        ctx.textAlign = 'center';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 4;
        ctx.strokeText('TRAINING COMPLETED!', canvas.width / 2, canvas.height / 2 - 80);
        ctx.fillText('TRAINING COMPLETED!', canvas.width / 2, canvas.height / 2 - 80);
        
        ctx.font = '24px Peralta';
        ctx.fillStyle = 'white';
        ctx.lineWidth = 3;
        ctx.strokeText('Training completed!', canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillText('Training completed!', canvas.width / 2, canvas.height / 2 - 20);
        
        ctx.font = '20px Peralta';
        ctx.strokeText(`Bottles hit: ${finalEnemiesDefeated}/10`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText(`Bottles hit: ${finalEnemiesDefeated}/10`, canvas.width / 2, canvas.height / 2 + 20);
        
        ctx.strokeText(`Shot used: ${shotsUsed}/10`, canvas.width / 2, canvas.height / 2 + 50);
        ctx.fillText(`Shot used: ${shotsUsed}/10`, canvas.width / 2, canvas.height / 2 + 50);
        
        ctx.font = '18px Peralta';
        ctx.fillStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.strokeText('Press ENTER for next level', canvas.width / 2, canvas.height / 2 + 100);
        ctx.fillText('Press ENTER for next level', canvas.width / 2, canvas.height / 2 + 100);
    }

    function completeLevel() {
        gameActive = false;
        showLevelCompleteScreen = true;
        finalEnemiesDefeated = enemiesDefeated;
        shotsUsed = 10 - shotsRemaining;
        requestAnimationFrame(draw);
    }

    function nextLevel() {
        window.location.href = 'Billy the shrimp.html';
    }

    function endGame() {
        gameActive = false;
        showGameOverScreen = true;
        finalEnemiesDefeated = enemiesDefeated;
        finalShotsRemaining = shotsRemaining;
        stopBackgroundMusic();
        requestAnimationFrame(draw);
    }

    function resetGame() {
        level = 1;
        enemiesDefeated = 0;
        shotsRemaining = 10;
        frames = 0;
        levelEl.innerText = '1';
        enemiesDefeatedEl.innerText = '0';
        shotsRemainingEl.innerText = '10';
        player.x = canvas.width / 2 - 40;
        player.y = canvas.height / 2 - 40;
        player.angle = 0;
        player.vx = 0; 
        player.vy = 0;
        player.facingRight = true;
        bullets = [];
        bottles = [];
        bubbles = [];
        currentFrame = 0;
        isCharging = false;
        isShooting = false;
        animationTimer = 0;
        gameActive = true;
        showGameOverScreen = false;
        showLevelCompleteScreen = false;
        showQuestScreen = false;
        startBackgroundMusic();
        update();
    }
    
    requestAnimationFrame(draw);
</script>

</body>
</html>